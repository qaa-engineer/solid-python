# SOLID с примерами на Python

<div data-gallery-root="" lang="ru" class="tm-article-body"><div></div> <div id="post-content-body"><div><div class="article-formatted-body article-formatted-body_version-2"><div xmlns="http://www.w3.org/1999/xhtml"><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/0be/025/27b/0be02527bca5ab9c8b9099c63d0a7c2a.png" width="780" height="439" data-src="https://habrastorage.org/getpro/habr/upload_files/0be/025/27b/0be02527bca5ab9c8b9099c63d0a7c2a.png"><figcaption></figcaption></figure><p>Эффективный алгоритм – основа работы эффективного программного обеспечения. Когда алгоритм уже есть, следующая задача – сделать так, чтобы ПО было разработано с использованием лучших методов проектирования и лучшей архитектуры. Специалисты, исследователи и эксперты определили лучшие практики эффективного проектирования программных приложений. Одной из наиболее популярных среди них являются принципы проектирования, известные под аббревиатурой SOLID.</p><p>Самыми известными и важными считаются принципы проектирования, предложенные Робертом К. Мартином (также известным как Дядя Боб). Дядя Боб представил много разных принципов проектирования, однако самых популярных всего 5, сокращенно их называют SOLID-принципами. В основном они сфокусированы вокруг объектно-ориентированной парадигмы проектирования ПО. Если учитывать эти рекомендации при разработке объектно-ориентированного ПО, код станет не таким сложным, снизится риск поломок, улучшится взаимодействие между различными объектами и код станет более гибким, читаемым и управляемым.&nbsp;</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/2a2/fff/e56/2a2fffe56b8706355d497fc1c0eff746.jpg" alt="Роберт К. Мартин (Дядя Боб)" title="Роберт К. Мартин (Дядя Боб)" width="1024" height="806" data-src="https://habrastorage.org/getpro/habr/upload_files/2a2/fff/e56/2a2fffe56b8706355d497fc1c0eff746.jpg"><figcaption>Роберт К. Мартин (Дядя Боб)</figcaption></figure><p>SOLID-принципы Дяди Боба расшифровываются следующим образом:</p><ul><li><p>S – Принцип единственной ответственности (Single Responsibility Principle),</p></li><li><p>O – Принцип открытости/закрытости (Open‐Closed Principle),</p></li><li><p>L – Принцип подстановки Барбары Лисков (Liskov Substitution Principle),</p></li><li><p>I – Принцип разделения интерфейсов (Interface Segregation Principle),</p></li><li><p>D – Принцип инверсии зависимостей (Dependency Inversion Principle).</p></li></ul><p>В этой статье я поделюсь своим пониманием принципов проектирования SOLID Роберта К. Мартина и снабжу его примерами на Python.</p><p><em>Примечание: </em>Примеры кода, которые я привожу, будут весьма минималистичны по своей природе, поскольку они написаны с единственной целью – объяснить соответствующий принцип. Они могут быть неполными или не соответствовать какому-либо другому принципу или передовой практике. Я прошу читателей принять это во внимание при чтении кода каждого принципа.</p><h3>Принцип единственной ответственности</h3><p>Принцип единой ответственности гласит, что у каждого класса должна быть только одна «ответственность» и он не должен брать на себя другие обязанности. Роберт К. Мартин объяснял его так: «У класса должна быть лишь одна причина для изменения».&nbsp;</p><p>Давайте в качестве примера возьмем приложение телефонного справочника. Мы будем делать телефонный справочник, в котором будет класс <code>TelephoneDirectory</code>. Он будет «нести ответственность» за ведение записей справочника, то есть телефонных номеров и названий организаций, которым принадлежат номера. Ожидается, что класс будет выполнять следующие операции: добавлять новую запись (<code>Name</code> и <code>Telephone</code><em> </em><code>Number</code>), удалять существующую запись, изменять номер телефона, присвоенный сущности <code>Name</code>, и предоставлять поиск, который будет возвращать номер, присвоенный сущности <code>Name</code>.</p><p>Класс <code>TelephoneDirectory</code> может выглядеть следующим образом:</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/24e/364/22d/24e36422d6c6d681c64c001628662a7d.jpg" width="670" height="578" data-src="https://habrastorage.org/getpro/habr/upload_files/24e/364/22d/24e36422d6c6d681c64c001628662a7d.jpg"><figcaption></figcaption></figure><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/81d/0e9/6a3/81d0e96a33b8f2e1c0e64a111be977d9.jpg" width="569" height="435" data-src="https://habrastorage.org/getpro/habr/upload_files/81d/0e9/6a3/81d0e96a33b8f2e1c0e64a111be977d9.jpg"><figcaption></figcaption></figure><p>Сейчас наш класс <code>TelephoneDirectory</code><em> </em>выглядит хорошо, в нем точно реализованы ожидаемые функции:</p><p>А теперь скажем, что в проекте есть еще два требования – Сохранить содержимое справочника в базе данных и перенести содержимое справочника в файл.&nbsp;</p><p>Теперь добавим еще два метода в класс <code>TelephoneDirectory</code><em>, </em>как показано ниже:</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/547/652/f95/547652f9538be2fc6d1e11583d930efd.jpg" width="826" height="747" data-src="https://habrastorage.org/getpro/habr/upload_files/547/652/f95/547652f9538be2fc6d1e11583d930efd.jpg"><figcaption></figcaption></figure><p>Так вот, именно сейчас мы нарушили принцип единственной ответственности. Добавив функции сохранения в базу данных и сохранения в файл, мы дали классу дополнительные обязанности, которые не входят в его основную зону ответственности. Теперь в классе есть дополнительные функции, которые могут привести к его изменению. В будущем, если появятся какие-то требования, связанные с сохранением данных, это может привести к изменениям в классе <code>TelephoneDirectory</code>. Получается, что класс <code>TelephoneDirectory</code> подвержен изменениям по причинам, которые не являются его основной ответственностью.</p><p>Принцип единственной ответственности требует от нас не добавлять дополнительные обязанности к классу, чтобы нам не приходилось менять класс, когда нам нужно изменить функционал сохранения справочника в базу данных или в файл. Мы можем передать экземпляр класса <code>TelephoneDirectory</code> экземплярам этих классов и записать любые дополнительные функции в них.</p><p>Так мы гарантируем, что у класса <code>TelephoneDirectory</code><em> </em>есть лишь одна причина для изменения – это изменения в его основной «ответственности».</p><figure class=""><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/e5d/33a/9d8/e5d33a9d80d3fb9f454369a3bf115047.jpg" width="501" height="242" data-src="https://habrastorage.org/getpro/habr/upload_files/e5d/33a/9d8/e5d33a9d80d3fb9f454369a3bf115047.jpg"><figcaption></figcaption></figure><p>Примеры кода выше вы можете найти <a href="https://github.com/amodiahs/SOLID_Design_Principles/tree/master/Single_Responsibility_Principle">на GitHub</a></p><h3>Принцип открытости/закрытости</h3><p>Принцип открытости/закрытости впервые был сформулирован Бернардом Мейером в 1988 году. Роберт К. Мартин говорил о нем так «Наиболее важный принцип открытости/закрытости гласит «Сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений».</p><p>Следование этому принципу гарантирует, что класс определен достаточно, чтобы делать то, что он должен делать. Добавление любых дополнительных функций может быть реализовано путем создания новых сущностей, которые расширяют возможности существующего класса и добавляют дополнительные функции самим себе. Таким образом можно предотвратить частые и тривиальные изменения в хорошо зарекомендовавшем себя классе низкого уровня.&nbsp;</p><p>Допустим, у нас есть приложение для магазина одежды. Среди функций системы есть функция применения специальных скидок в зависимости от типа одежды.&nbsp;</p><p>Пример ниже показывает один из способов реализации этого требования.</p><p>В примере у нас есть класс <code>DiscountCalculator</code>, который умеет хранить тип одежды. В нем есть функция, которая рассчитывает скидку в зависимости от типа одежды и возвращает новую стоимость за вычетом суммы скидки.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/b76/65f/97f/b7665f97f84efde9bf55d806120a7b05.png" width="590" height="753" data-src="https://habrastorage.org/getpro/habr/upload_files/b76/65f/97f/b7665f97f84efde9bf55d806120a7b05.png"><figcaption></figcaption></figure><p>Эта конструкция нарушает принцип открытости/закрытости, поскольку этот класс потребует изменения, если будет добавляться какой-то тип одежды или если сумма скидки на какую-либо одежду изменится.</p><figure class=""><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/d7a/193/3bc/d7a1933bc156bb543e5a065d33fbe8f0.png" width="462" height="778" data-src="https://habrastorage.org/getpro/habr/upload_files/d7a/193/3bc/d7a1933bc156bb543e5a065d33fbe8f0.png"><figcaption></figcaption></figure><p>Как видно из примера выше, теперь у нас есть очень простой базовый класс <code>DiscountCalculator</code> с одним абстрактным методом <code>get_discounted_price</code>. Мы создали новые классы для одежды, которые расширяют базовый класс <code>DiscountCalculator</code>. Следовательно, теперь каждый подкласс будет реализовывать функционал скидок самостоятельно. Сделав так, мы устранили предыдущие ограничения, которые требовали внесения изменений в базовый класс. Теперь, не изменяя базовый класс, мы можем добавлять больше одежды, а также изменять размер скидки на отдельный вид одежды по мере необходимости.</p><p>Примеры кода выше вы можете найти <a href="https://github.com/amodiahs/SOLID_Design_Principles/tree/master/Open_Closed_Principle">на GitHub</a></p><h3>Принцип подстановки Барбары Лисков</h3><p>Принцип подстановки Лисков был одним из самых сложных принципов для меня, и чтобы понять его правильно, мне пришлось посмотреть различные примеры в Интернете. Я считаю, что после осознания, этот принцип станет одним из самых простых, среди принципов, которых следует придерживаться при разработке объектно-ориентированных приложений.</p><p>Принцип подстановки Лисков гласит: «Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы».</p><p>Принцип подстановки Лисков был предложен Барбарой Лисков. Он предполагает отношение подтипов, называемое сильным поведенческим подтипом. Этот принцип говорит нам о том, что если класс <code>Sub</code> является подтипом класса <code>Sup</code>, тогда в программе объекты типа <code>Sup</code> должны легко заменяться объектами типа <code>Sub</code> без необходимости изменения кода. Дядя Боб включил этот принцип в число 5 лучших принципов проектирования SOLID.</p><p>Допустим, у нас есть базовый класс <code>Car</code>, который отвечает за тип автомобиля. Класс <code>Car</code> наследуется подклассом <code>PetrolCar</code>. Аналогично, базовый класс <code>Car</code> может быть унаследован другими классами, которые могут расширять его возможности.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/0a8/98f/f5b/0a898ff5b57b0ac776e9206b7a421f58.png" width="698" height="515" data-src="https://habrastorage.org/getpro/habr/upload_files/0a8/98f/f5b/0a898ff5b57b0ac776e9206b7a421f58.png"><figcaption></figcaption></figure><p>Как мы видим здесь, стандартной спецификации для добавления свойств <code>Car</code> не существует, и разработчикам остается реализовать ее удобным для них способом. Один разработчик может реализовать ее как словарь, а другой как кортеж. Таким образом, она может быть реализована несколькими способами.</p><p>Пока проблем нет. Но давайте предположим, что есть задача найти все автомобили красного цвета. Давайте попробуем написать функцию, которая брала бы все автомобили и пыталась найти все красные путем реализации объекта суперкласса <code>Car</code>.&nbsp;</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/739/021/6ee/7390216ee49b1d7fe84643c961380c36.png" width="665" height="761" data-src="https://habrastorage.org/getpro/habr/upload_files/739/021/6ee/7390216ee49b1d7fe84643c961380c36.png"><figcaption></figcaption></figure><p>Как видно из кода, мы пытаемся просмотреть список объектов <code>Car</code>. Именно здесь мы нарушаем принцип подстановки Лисков, поскольку мы не можем заменить объекты супертипа <code>Car</code> объектами подтипа <code>PetrolCar</code> внутри функции поиска красных автомобилей.</p><p>Лучшим варианты было бы реализовать методы <code>setter</code> и <code>getter</code><em> </em>в суперклассе <code>Car</code>. С их помощью мы можем устанавливать и получать свойства автомобиля, не оставляя эту реализацию последующим разработчикам. Таким образом, мы просто получаем свойства с помощью метода <code>setter</code>, и его реализация остается инкапсулированной в суперклассе.</p><p>Так мы сможем соблюсти принцип подстановки Лисков, как показано ниже:</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/da6/c6d/377/da6c6d3778df2a1aea64a3b0bec00a1a.png" width="664" height="691" data-src="https://habrastorage.org/getpro/habr/upload_files/da6/c6d/377/da6c6d3778df2a1aea64a3b0bec00a1a.png"><figcaption></figcaption></figure><p>Примеры кода выше вы можете найти<a href="https://github.com/amodiahs/SOLID_Design_Principles/tree/master/Liskov_Substitution_Principle"> на GitHub</a></p><h3>Принцип разделения интерфейсов</h3><p>Принцип разделения интерфейсов гласит, что «Ни один клиент не должен зависеть от методов, которые он не использует».&nbsp;</p><p>Принцип разделения интерфейсов был предложен Робертом К. Мартином, когда он консультировал компанию Xerox.</p><p>Принцип разделения интерфейсов предполагает создание небольших интерфейсов, известных как «ролевые интерфейсы», вместо большого интерфейса, состоящего из нескольких методов. Разделяя методы по ролям на более мелкие интерфейсы, клиенты будут зависеть только от методов, которые имеют к ним отношение.</p><p>Допустим, мы разрабатываем приложение для различных коммуникационных устройств. Мы говорим, что устройство связи – это устройство, которое будет иметь одну или несколько из следующих функций: совершать звонки, отправлять SMS или искать в Интернете. Итак, мы создаем интерфейс с именем <code>CommunicationDevice</code> и добавляем соответствующие абстрактные методы для каждой из этих функций, чтобы любой создаваемый класс смог реализовать эти методы.</p><p>Затем мы создаем класс <code>SmartPhone</code> с помощью интерфейса <code>CommunicationDevice</code> и реализуем функционал абстрактных методов. До сих пор все было в порядке.</p><p>Теперь предположим, что нам нужно создать стационарный телефон. Он тоже является устройством связи, поэтому мы создаем новый класс <code>LandlinePhone</code> через тот же интерфейс <code>CommunicationDevice</code>. Именно здесь мы сталкиваемся с проблемой из-за объемного интерфейса <code>CommunicationDevice</code>. В классе <code>LandlinePhone</code> мы реализовываем метод <code>make_calls()</code>, но поскольку мы также наследуем абстрактные методы <code>send_sms()</code> и <code>browse_internet()</code>, мы должны предоставить реализацию и этих двух абстрактных методов в классе <code>LandlinePhone</code>, даже если они в принципе неприменимы к этому виду телефонов. Мы можем либо создать исключение, либо оставить <code>pass</code> вместо реализации, но нам все равно нужно ее предоставить.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/6d1/034/8e5/6d10348e5d522c8197240ec590a381e7.png" width="627" height="778" data-src="https://habrastorage.org/getpro/habr/upload_files/6d1/034/8e5/6d10348e5d522c8197240ec590a381e7.png"><figcaption></figcaption></figure><p>Все можно исправить, следуя принципу разделения интерфейсов, как в примере ниже. Вместо создания большого интерфейса мы создаем более маленькие ролевые интерфейсы для каждого метода. Соответствующие классы будут использовать только связанные интерфейсы.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/454/41e/29b/45441e29b0c3bc952ec306da2adddaae.png" width="654" height="733" data-src="https://habrastorage.org/getpro/habr/upload_files/454/41e/29b/45441e29b0c3bc952ec306da2adddaae.png"><figcaption></figcaption></figure><p>Примеры кода выше вы можете найти<a href="https://github.com/amodiahs/SOLID_Design_Principles/tree/master/Interface_Segregation_Principle"> на GitHub</a></p><h3>Принцип инверсии зависимостей</h3><p>Принцип инверсии зависимостей гласит:</p><ol><li><p>Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций.&nbsp;</p></li><li><p>Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.</p></li></ol><p>Если ваш код уже реализует принципы открытости/закрытости и подстановки Лисков, он уже будет неявно согласован с принципом инверсии зависимостей.&nbsp;&nbsp;</p><p>Следуя принципу открытости/закрытости, вы создаете интерфейсы, которые можно использовать для предоставления различных высокоуровневых реализаций. Следуя принципу подстановки Лисков, вы гарантируете, что сможете заменить экземпляры класса низкого уровня объектами класса высокого уровня без какого-либо негативного воздействия на приложение. Таким образом, следуя этим двум принципам, вы гарантируете, что ваши классы высокого уровня и классы низкого уровня зависят от интерфейсов. Следовательно, вы неявно следуете принципу инверсии зависимостей.</p><p>Как показано в коде ниже, у нас есть класс <code>Student</code>, который мы используем для создания экземпляров <code>Student</code> и класса <code>TeamMemberships</code>, который содержатся сведения о принадлежности учеников к разным командам.</p><p>Теперь мы определим высокоуровневый класс <code>Analysis</code>, где нам нужно отсеять всех учеников, принадлежащих красной команде.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/720/39d/ae7/72039dae771335ee9de1eec386a992e6.jpg" width="589" height="756" data-src="https://habrastorage.org/getpro/habr/upload_files/720/39d/ae7/72039dae771335ee9de1eec386a992e6.jpg"><figcaption></figcaption></figure><p>Как видно из реализации, мы напрямую используем <code>team_student_memberships.team_memberships</code> в высокоуровневом классе <code>Analysis</code>, и мы используем реализацию этого списка непосредственно в классе высокого уровня. На данный момент все нормально, но представьте ситуацию, в которой нам нужно изменить эту реализацию со списка на что-то другое. В этом случае наш класс высокого уровня <code>Analysis</code> сломается, поскольку он зависит от деталей реализации <code>TeamMemberships</code> низкого уровня.</p><p>Теперь взгляните на пример ниже, в котором мы меняем эту реализацию и приводим ее в соответствие с принципом инверсии зависимостей.</p><figure class="full-width "><img src="https://habrastorage.org/r/w1560/getpro/habr/upload_files/229/3f0/aec/2293f0aeccebe989bfcc7a1cf883a5a5.jpg" width="595" height="760" data-src="https://habrastorage.org/getpro/habr/upload_files/229/3f0/aec/2293f0aeccebe989bfcc7a1cf883a5a5.jpg"><figcaption></figcaption></figure><p>Чтобы следовать принципу инверсии зависимостей, нам необходимо убедиться, что класс высокого уровня <code>Analysis</code> не зависит от конкретной реализации класса низкого уровня <code>TeamMembership</code>. Вместо этого он должен зависеть от некоторой абстракции.</p><p>Итак, мы создаем интерфейс <code>TeamMembershipLookup</code>, который содержит абстрактный метод <code>find_all_students_of_team</code>, передающийся любому классу, наследующему этот интерфейс. Мы наследуем наш класс <code>TeamMembership</code> от этого интерфейса, следовательно, теперь класс <code>TeamMembership</code> должен предоставлять реализацию функции <code>find_all_students_of_team</code>. Затем эта функция передает результаты любому другому вызывающему ее объекту. Мы перенесли обработку, которая делалась в классе высокого уровня <code>Analysis</code> в <code>TeamMemberships</code> через интерфейс <code>TeamMembershipLookup</code>.</p><p>Сделав все это, мы убрали зависимость класса <code>Analysis</code> от класса <code>TeamMemberships</code> и перенесли ее в интерфейс <code>TeamMembershipLookup</code>. Теперь класс высокого уровня не зависит от деталей реализации класса низкого уровня. Любые изменения в деталях реализации класса низкого уровня не влияют на класс высокого уровня.</p><p>Примеры кода выше вы можете найти <a href="https://github.com/amodiahs/SOLID_Design_Principles/tree/master/Dependency_Inversion_Principle">на GitHub</a></p><p><strong>Итог:</strong></p><div><div class="table"><div class="table table_wrapped"><table><tbody><tr><td data-colwidth="177" width="177"><p><strong>Принцип</strong></p></td><td><p><strong>Смысл</strong></p></td></tr><tr><td data-colwidth="177" width="177"><p>Принцип единственной ответственности</p></td><td><p>У класса должна быть всего одна причина для изменения.</p></td></tr><tr><td data-colwidth="177" width="177"><p>Принцип открытости/закрытости</p></td><td><p>Сущности программы (классы, модули, функции и т.п.) должны быть открыты для расширения, но закрыты для изменений.</p></td></tr><tr><td data-colwidth="177" width="177"><p>Принцип подстановки Барбары Лисков</p></td><td><p>Объекты в программе должны быть заменяемы экземплярами их подтипов без ущерба корректности работы программы.</p></td></tr><tr><td data-colwidth="177" width="177"><p>Принцип разделения интерфейсов</p></td><td><p>Ни один клиент не должен зависеть от методов, которые он не использует.</p></td></tr><tr><td data-colwidth="177" width="177"><p>Принцип инверсии зависимостей</p></td><td><p>Модуль высокого уровня не должен зависеть от модулей низкого уровня. И то, и другое должно зависеть от абстракций.&nbsp;</p><p>Абстракции не должны зависеть от деталей реализации. Детали реализации должны зависеть от абстракций.</p></td></tr></tbody></table></div></div></div><p><em>Примечание: </em>Весь код на Python из этой статьи можно загрузить <a href="https://github.com/amodiahs/SOLID_Design_Principles">с моего GitHub</a> вместе с PDF-файлом этой статьи.</p>
